//
//  This file is part of the 2FAS iOS app (https://github.com/twofas/2fas-ios)
//  Copyright © 2023 Two Factor Authentication Service, Inc.
//  Contributed by Zbigniew Cisiński. All rights reserved.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program. If not, see <https://www.gnu.org/licenses/>
//

import Foundation
import Common

final class CodeParser {
    func parse(codeStr: String) -> Code? {
        guard let codeStr = handleEncodedCharacters(for: codeStr), !codeStr.isEmpty else { return nil }
        
        guard let components = NSURLComponents(string: codeStr) else { return nil }
        guard let scheme = components.scheme, scheme == "otpauth" else { return nil }
        guard let query = components.queryItems else { return nil }
        
        let label = components.path?.trimmingCharacters(in: .init(charactersIn: "/"))
        let items = queryItems(query: query)
        
        // Verify if code is of TOTP type
        // Encoder key is used by KeePassXC for Steam keys
        guard let tokenType = items.find(forType: .other("encoder", ""))?.value ?? components.host else { return nil }
        
        // Locate and validate secret
        guard let secret = items.find(forType: .secret(""))?
            .value
            .sanitazeSecret(),
              secret.isValidSecret()
        else { return nil }
        
        let issuer = items.find(forType: .issuer(""))
        let period: String? = items.find(forType: .period(""))?.value
        let digits: String? = items.find(forType: .digits(""))?.value
        let algorithm: String? = items.find(forType: .algorithm(""))?.value
        let counter: Int? = {
            guard let value = items.find(forType: .counter(""))?.value else { return nil }
            return Int(value)
        }()
        let otpAuth: String = {
            let itemsList: String = {
                var list: String = ""
                for i in items {
                    let key = i.key
                    var value = i.value
                    
                    if case QueryItemsType.secret = i {
                        value = Config.hiddenSecret
                    }
                    list += "\(key)=\(value)&"
                }
                
                return list
            }()
            var path: String = {
                if let label {
                    return "\(scheme)://\(tokenType)/\(label)?\(itemsList)"
                }
                return "\(scheme)://\(tokenType)/?\(itemsList)"
            }()
            if path.last == "?" || path.last == "&" {
                path.removeLast()
            }
            return path
        }()
        
        guard Digits.verifyIfPresent(digits),
              Period.verifyIfPresent(period),
              Algorithm.verifyIfPresent(algorithm) else { return nil }
        
        return Code(
            issuer: issuer?.value.replacingOccurrences(of: "+", with: " "),
            label: label,
            secret: secret,
            period: Period.create(period),
            digits: Digits.create(digits),
            algorithm: Algorithm.create(algorithm),
            tokenType: TokenType.create(tokenType),
            counter: counter,
            otpAuth: otpAuth
        )
    }
        
    private func queryItems(query: [URLQueryItem]) -> [QueryItemsType] {
        var values: [QueryItemsType] = []
        
        for item in query {
            guard let value = item.value?.removingPercentEncoding else { continue }
            let parsedItem = QueryItemsType(key: item.name, value: value)
            values.append(parsedItem)
        }
        
        return values
    }
    
    private func handleEncodedCharacters(for str: String) -> String? {
        let parts = str.split(separator: "?")
        
        guard parts.count < 3 else { return nil }
        
        var completeValue = ""
        
        if let first = parts.first {
            completeValue += replaceEncodedCharacters(for: String(first))
        }
        
        if let second = parts.last {
            completeValue += "?\(removeEncodedCharacters(for: String(second)))"
        }
        
        return completeValue
    }
    
    private func replaceEncodedCharacters(for str: String) -> String {
        str.trimmingCharacters(in: .whitespacesAndNewlines)
            .replacingOccurrences(of: " ", with: "%20")
            .replacingOccurrences(of: "&amp;", with: "%26")
            .replacingOccurrences(of: "&lt;", with: "%3C")
            .replacingOccurrences(of: "&gt;", with: "%3E")
            .replacingOccurrences(of: "&quot;", with: "%22")
            .replacingOccurrences(of: "&apos;", with: "%27")
            .replacingOccurrences(of: "[", with: "%5B")
            .replacingOccurrences(of: "]", with: "%5D")
    }
    
    private func removeEncodedCharacters(for str: String) -> String {
        str.trimmingCharacters(in: .whitespacesAndNewlines)
            .replacingOccurrences(of: " ", with: "%20")
            .replacingOccurrences(of: "&amp;", with: "&")
    }
 }
